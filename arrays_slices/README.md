# Массивы и слайсы

## Массивы

- Способы создания массивов

[`Creation`](./arrays/creation/main.go)

> **Где аллоцируются массивы?**

- Если размер массива не больше `128КБ` (Go 1.25), то массив создается на стеке.

[`128KB`](./arrays/allocation/128KB/main.go)

- Но нужно помнить об `escape analysis`

**Escape Analysis (анализ побегов)** — это техника оптимизации работы с памятью, которая помогает компилятору решать, когда объекты, созданные в функциях, могут быть размещены в стеке или должны оставаться в куче. 

**Принцип работы**

Компилятор анализирует, «убегает» ли указатель на объект за пределы функции, в которой он был создан. Некоторые ситуации, когда объект «убегает»:

- возвращается из функции;
- передаётся в другой поток;
- назначается в глобальной переменной.

[`EscapeToHeap`](./arrays/allocation/espace/main.go)

### Итерирование по массивам

При использовании классического `range` над массивом происходит копирование массива во временную переменную.

Для больших массивов это может быть критично. Чтобы эту проблему решить, нужно либо передавать указатель в `range` или создавать из массива `slice`
```go
for value := range array {}    // Copy of array
for value := range &array {}   // Copy of array address. Ok
for value := range array[:] {} // Copy of slice. Ok
```

[`Benchmark`](./arrays/iteration_bench/bench_test.go)

## Слайсы

В Go за срезом находится массив. Это означает, что данные среза хранятся в структуре данных массив

```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

Хоть и срез это структура, но **zero value** для него это **nil**.

- Способы создания срезов

[`Creation`](./slices/creation/main.go)

- Операции и ограничения над слайсами

[`Operations`](./slices/operations/main.go)

- Читать и писать в нулевой срез нельзя, будет паника. Т.к у такого среза length = 0
- Итерироваться и добавлять элементы в нулевой срез можно.

> **Как изменяется размер среза по мере добавления элементов?**

[`SliceGrowing`](./slices/slice_growing/main.go)

[`PR to Golang source code`](https://go-review.googlesource.com/c/go/+/347917)
```txt
runtime: make slice growth formula a bit smoother

Instead of growing 2x for < 1024 elements and 1.25x for >= 1024 elements,
use a somewhat smoother formula for the growth factor. Start reducing
the growth factor after 256 elements, but slowly.

starting cap    growth factor
256             2.0
512             1.63
1024            1.44
2048            1.35
4096            1.30

(Note that the real growth factor, both before and now, is somewhat
larger because we round up to the next size class.)
```

> **Как избежать инициализации элементов за пределами размера массива при выделении памяти?**

Если массив имеет размер `3`, а capacity `6`, все `6` элементов будут заполнены нулевыми значениями.

[`Dirty slice`](./slices/dirty_slice/main.go)

- С помощью unsafe функций можно сделать неизменяемые строки изменяемыми, используя уже выделенную память.

[`Mutate string`](./slices/conversion/mutate_string/main.go)

- Также можно создавать строки из массива байт без выделения новой памяти, используя уже выделенный для слайса буфер.

[`ToString`](./slices/conversion/to_string/main.go)

- Обратно: из строки можно создать слайс без дополнительных аллокаций.

[`FromString`](./slices/conversion/from_string/main.go)

## Subslicing

Под срез указывается в виде **Полуоткрытого справа интервала `[X,Y)`**

```go
slice0 := []int{1,2,3,4,5}

slice1 := slice0[1:3] // [2,3]
slice2 := slice0[:]   // [1,2,3,4,5]
slice3 := slice0[:3]  // [1,2,3]
slice4 := slice0[1:]  // [2,3,4,5]
```

Индексы указываемые в интервале могут быть в пределах `[0, cap(slice)]`. Иначе паника.

При создании подслайса из существующего слайса, его capacity обновляется. Она отражает количество элементов от начала нового слайса до конца исходного.

[`SubsliceCapacity`](./slices/capacity/main.go)

При создании подслайсов не происходит аллокаций, т.к они разделяют один общий участок памяти.

> При изменении длины/емкости одного среза, изменения никак не отражаются на другом срезе. Т.к срез это структура которая имеется собственные поля размера и емкости

```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

> Когда слайс подвергается реаллокации, он отделяется от старого буфера и получает собственную область памяти.

### Slice unpacking (Распаковка слайса)

Распаковка происходит при помощи синтаксиса `...`

[`SliceUnpack`](./slices/unpack/main.go)

> **Где аллоцируются слайсы?**

- Если размер среза не больше `64КБ` (Go 1.25), то срез создается на стеке.

[`64KB`](./slices/allocation/64KB/main.go)

- Но нужно помнить об `escape analysis`

> Но когда происходит реаллокация среза, независимо от его размера и где он был создан, он перевыделится на куче

[`Realloc`](./slices/allocation/realloc/main.go)

> **Как очистить слайс?**

[`ClearSlice`](./slices/clearing/main.go)

> **В чем разница между пустым и нулевым срезом?**

- Срез считается пустым, если его `длина` равна `нулю`
- Срез считается нулевым, если он равен `nil`

> **Можно ли сравнивать срезы?**

- Явно через оператор `==` нельзя

Можно использовать `slices.Equal` или `reflect.DeepEqual`

> **Почему функция `append` возвращает срез?**

Когда срез передают в функцию, происходит копирование его заголовка. Это значит, что изменения, внесенные в локальный заголовок внутри функции, не видны извне. Хотя буфер под слайсом может изменяться, эти изменения не отражаются из-за неизмененного заголовка. Но если явно руками сдвинуть границы среза после вызова модернизирубщей функции, то изменения там будут.

```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

[`SliceProblem`](./slices/problem/main.go)


> **Как нужно делать?**

Возвращать срез из функции, которая изменяет его заголовок (например, меняет размер или производит релокацию). Не зря же `append` возвращает после манипуляций новый заголовок среза
